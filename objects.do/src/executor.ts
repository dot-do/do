/**
 * objects.do Executor - Safe function execution using ai-evaluate
 *
 * Uses Cloudflare worker_loaders for secure sandboxed execution.
 * For handlers that need the full $ context, we pass bindings to the sandbox.
 */

import type { DOContext, ExecutionResult, WorkerLoader } from './types'

// =============================================================================
// Execution Types
// =============================================================================

/**
 * Options for function execution
 */
export interface ExecuteOptions {
  /** Maximum execution time in milliseconds */
  timeout?: number

  /** Enable strict mode (more restrictions) */
  strict?: boolean

  /** Allow network access from sandbox */
  allowFetch?: boolean

  /** Explicit parameter names from method definition */
  methodParams?: string[]
}

/**
 * Sandbox environment with worker_loaders binding
 */
export interface SandboxEnv {
  LOADER?: WorkerLoader
}

// =============================================================================
// Function Parsing
// =============================================================================

/**
 * Parse a stringified function to extract parameters and body
 */
export function parseFunction(code: string): { params: string[]; body: string; isAsync: boolean } {
  const trimmed = code.trim()

  // Match arrow function: async (a, b, c) => { ... } or async a => ...
  const arrowMatch = trimmed.match(/^(async\s+)?\(?\s*([^)=]*?)\s*\)?\s*=>\s*(.*)$/s)
  if (arrowMatch) {
    const isAsync = !!arrowMatch[1]
    const paramsStr = arrowMatch[2].trim()
    const body = arrowMatch[3].trim()

    const params = paramsStr ? paramsStr.split(',').map((p) => p.trim().split('=')[0].trim()).filter(Boolean) : []

    // Handle expression body vs block body
    if (body.startsWith('{')) {
      // Block body - remove outer braces
      const innerBody = body.slice(1, -1).trim()
      return { params, body: innerBody, isAsync }
    } else {
      // Expression body - wrap in return
      return { params, body: `return (${body})`, isAsync }
    }
  }

  // Match function expression: async function(a, b, c) { ... }
  const funcMatch = trimmed.match(/^(async\s+)?function\s*\w*\s*\(([^)]*)\)\s*\{(.*)\}$/s)
  if (funcMatch) {
    const isAsync = !!funcMatch[1]
    const paramsStr = funcMatch[2].trim()
    const body = funcMatch[3].trim()

    const params = paramsStr ? paramsStr.split(',').map((p) => p.trim().split('=')[0].trim()).filter(Boolean) : []

    return { params, body, isAsync }
  }

  // If we can't parse it, treat the whole thing as a function body
  return { params: [], body: code, isAsync: code.includes('await') }
}

// =============================================================================
// Worker Code Generation
// =============================================================================

/**
 * Generate sandbox worker code that executes the handler
 */
function generateSandboxWorkerCode(options: {
  code: string
  params: unknown[]
  contextData?: Record<string, unknown>
  methodParams?: string[]
}): string {
  const { code, params, contextData = {}, methodParams } = options
  const parsed = parseFunction(code)
  // Use explicit methodParams if the code doesn't define its own params
  const funcParams = parsed.params.length > 0 ? parsed.params : (methodParams || [])
  const { body, isAsync } = parsed

  // Serialize params for embedding
  const serializedParams = JSON.stringify(params)
  const serializedContext = JSON.stringify(contextData)

  // Build the handler function
  const handlerFn = isAsync
    ? `async function handler(${funcParams.join(', ')}) { ${body} }`
    : `function handler(${funcParams.join(', ')}) { ${body} }`

  return `
// Sandbox Worker - Generated by objects.do executor
const logs = [];

// Capture console output
const originalConsole = { ...console };
const captureConsole = (level) => (...args) => {
  logs.push({
    level,
    message: args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' '),
    timestamp: Date.now()
  });
  originalConsole[level](...args);
};
console.log = captureConsole('log');
console.warn = captureConsole('warn');
console.error = captureConsole('error');
console.info = captureConsole('info');

// Context data from parent (serializable parts only)
const $ = ${serializedContext};

// The handler function
${handlerFn}

export default {
  async fetch(request, env) {
    const start = Date.now();
    try {
      const params = ${serializedParams};
      const result = await handler(...params);

      return Response.json({
        success: true,
        result,
        logs,
        duration: Date.now() - start
      });
    } catch (error) {
      return Response.json({
        success: false,
        error: {
          code: 'EXECUTION_ERROR',
          message: error.message || String(error),
          stack: error.stack
        },
        logs,
        duration: Date.now() - start
      });
    }
  }
};
`
}

// =============================================================================
// Safe Function Execution
// =============================================================================

/**
 * Execute a stringified function with the given context and parameters
 *
 * Uses worker_loaders for secure sandboxed execution when available.
 *
 * @param code - Stringified function code
 * @param $ - The DO context to inject (serializable parts only)
 * @param params - Parameters to pass to the function
 * @param options - Execution options
 * @param sandboxEnv - Sandbox environment with LOADER binding
 * @returns Execution result
 */
export async function executeFunction<T = unknown>(
  code: string,
  $: DOContext | null,
  params: unknown[] = [],
  options: ExecuteOptions = {},
  sandboxEnv?: SandboxEnv
): Promise<ExecutionResult<T>> {
  const startTime = performance.now()

  try {
    // Check for LOADER binding
    const loader = sandboxEnv?.LOADER
    if (!loader) {
      return {
        success: false,
        error: {
          code: 'SANDBOX_ERROR',
          message: 'Sandbox requires worker_loaders binding. Add to wrangler.jsonc: "worker_loaders": [{ "binding": "LOADER" }]',
        },
        duration: performance.now() - startTime,
      }
    }

    // Extract serializable context data from $
    const contextData: Record<string, unknown> = {}
    if ($) {
      // Only include serializable properties
      contextData.$id = $.$id
      contextData.$type = $.$type
      if ($.$context) {
        contextData.$context = $.$context
      }
      // Note: Functions like $.ai, $.db cannot be serialized to sandbox
      // These would require RPC proxying for full support
    }

    // Generate the sandbox worker code
    const workerCode = generateSandboxWorkerCode({
      code,
      params,
      contextData,
      methodParams: options.methodParams,
    })

    // Create unique ID for this sandbox
    const id = `sandbox-${Date.now()}-${Math.random().toString(36).slice(2)}`

    // Create the sandbox worker
    const worker = loader.get(id, async () => ({
      mainModule: 'worker.js',
      modules: {
        'worker.js': workerCode,
      },
      compatibilityDate: '2024-12-01',
      // Block network access unless explicitly allowed
      globalOutbound: options.allowFetch ? undefined : null,
    }))

    // Execute the handler
    const entrypoint = worker.getEntrypoint()
    const response = await entrypoint.fetch(new Request('http://sandbox/execute'))
    const result = (await response.json()) as {
      success: boolean
      result?: T
      error?: { code: string; message: string; stack?: string }
      logs?: Array<{ level: string; message: string; timestamp: number }>
      duration: number
    }

    if (result.success) {
      return {
        success: true,
        result: result.result as T,
        duration: performance.now() - startTime,
      }
    } else {
      return {
        success: false,
        error: result.error || { code: 'EXECUTION_ERROR', message: 'Unknown error' },
        duration: performance.now() - startTime,
      }
    }
  } catch (error) {
    const err = error instanceof Error ? error : new Error(String(error))

    return {
      success: false,
      error: {
        code: 'EXECUTION_ERROR',
        message: err.message,
        stack: err.stack,
      },
      duration: performance.now() - startTime,
    }
  }
}

// =============================================================================
// Code Validation
// =============================================================================

/**
 * List of dangerous globals that should be blocked
 */
const BLOCKED_GLOBALS = [
  'process',
  'require',
  'eval',
  'globalThis',
  'global',
  '__dirname',
  '__filename',
  'module',
  'exports',
  'importScripts',
]

/**
 * Validate function code for obvious security issues
 * Returns true if the code appears safe, false otherwise
 */
export function validateFunctionCode(code: string): { valid: boolean; reason?: string } {
  // Check for direct access to blocked globals
  for (const global of BLOCKED_GLOBALS) {
    // Match standalone access (not as property)
    const regex = new RegExp(`\\b${global}\\b(?!\\s*[:\\]])`, 'g')
    if (regex.test(code)) {
      return { valid: false, reason: `Access to '${global}' is not allowed` }
    }
  }

  // Check for Function constructor usage
  if (/new\s+Function\s*\(/.test(code)) {
    return { valid: false, reason: 'Function constructor is not allowed' }
  }

  // Check for eval usage
  if (/\beval\s*\(/.test(code)) {
    return { valid: false, reason: 'eval is not allowed' }
  }

  return { valid: true }
}

/**
 * Extract parameter names from function code
 */
export function extractParams(code: string): string[] {
  const { params } = parseFunction(code)
  return params
}
