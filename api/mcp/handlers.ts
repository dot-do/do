/**
 * MCP Request Handlers
 *
 * Handles Model Context Protocol JSON-RPC requests.
 * CRUD tools are auto-generated by @dotdo/apis database convention.
 * This file only contains custom AI tools and system tools.
 */

import type { Env } from '../types'
import type { MCPServerInfo, MCPTool, MCPToolCallResponse, MCPListToolsResponse } from './index'

// Local type for tool definition that's more permissive
type ToolDef = {
  name: string
  description?: string
  inputSchema: {
    type: 'object'
    properties?: Record<string, unknown>
    required?: string[]
  }
}

// =============================================================================
// Tool Definitions
// =============================================================================

/**
 * Get custom MCP tools (non-CRUD)
 *
 * CRUD tools are auto-generated by @dotdo/apis database convention.
 * This function returns only custom tools (AI, system, CDC, schedule).
 */
export function getTools(): MCPTool[] {
  const tools: ToolDef[] = [
    // Identity
    {
      name: 'do.identity.get',
      description: 'Get the identity of this Digital Object ($id, $type, $context, $version)',
      inputSchema: { type: 'object' },
    },
    {
      name: 'do.identity.setContext',
      description: 'Set the parent context for CDC streaming',
      inputSchema: {
        type: 'object',
        properties: {
          context: { type: 'string', description: 'Parent DO URL (e.g., https://parent.domain)' },
        },
        required: ['context'],
      },
    },

    // System
    {
      name: 'do.system.ping',
      description: 'Health check - returns pong with timestamp',
      inputSchema: { type: 'object' },
    },
    {
      name: 'do.system.stats',
      description: 'Get DO statistics (storage, connections, CDC)',
      inputSchema: { type: 'object' },
    },
    {
      name: 'do.system.schema',
      description: 'Get DO schema (available methods and collections)',
      inputSchema: { type: 'object' },
    },

    // CDC
    {
      name: 'do.cdc.subscribe',
      description: 'Subscribe to change data capture events',
      inputSchema: {
        type: 'object',
        properties: {
          collections: { type: 'array', items: { type: 'string' }, description: 'Collections to subscribe to' },
        },
      },
    },
    {
      name: 'do.cdc.getChanges',
      description: 'Get CDC changes since a cursor (pull-based)',
      inputSchema: {
        type: 'object',
        properties: {
          cursor: { type: 'string', description: 'CDC cursor' },
          limit: { type: 'number', description: 'Max events to return' },
        },
      },
    },

    // Schedule
    {
      name: 'do.schedule',
      description: 'Schedule a callback at a specific time',
      inputSchema: {
        type: 'object',
        properties: {
          when: { type: 'string', description: 'ISO date, delay in seconds, or cron expression' },
          callback: { type: 'string', description: 'Method name to call' },
          payload: { type: 'object', description: 'Data to pass' },
        },
        required: ['when', 'callback'],
      },
    },
    {
      name: 'do.schedule.list',
      description: 'List all scheduled callbacks',
      inputSchema: { type: 'object' },
    },
    {
      name: 'do.schedule.cancel',
      description: 'Cancel a scheduled callback',
      inputSchema: {
        type: 'object',
        properties: {
          id: { type: 'string', description: 'Schedule ID' },
        },
        required: ['id'],
      },
    },

    // AI
    {
      name: 'ai.generate',
      description: 'Generate text using AI',
      inputSchema: {
        type: 'object',
        properties: {
          prompt: { type: 'string', description: 'The prompt to generate from' },
          model: { type: 'string', description: 'Model characteristic: best, fast, cost, code, reasoning' },
          system: { type: 'string', description: 'System prompt' },
          maxTokens: { type: 'number', description: 'Maximum tokens to generate' },
          temperature: { type: 'number', description: 'Temperature (0-2)' },
        },
        required: ['prompt'],
      },
    },
    {
      name: 'ai.chat',
      description: 'Chat completion with AI',
      inputSchema: {
        type: 'object',
        properties: {
          messages: {
            type: 'array',
            items: {
              type: 'object',
              properties: {
                role: { type: 'string', enum: ['system', 'user', 'assistant'] },
                content: { type: 'string' },
              },
              required: ['role', 'content'],
            },
            description: 'Chat messages',
          },
          model: { type: 'string', description: 'Model characteristic' },
        },
        required: ['messages'],
      },
    },
    {
      name: 'ai.embed',
      description: 'Generate embeddings',
      inputSchema: {
        type: 'object',
        properties: {
          text: {
            oneOf: [{ type: 'string' }, { type: 'array', items: { type: 'string' } }],
            description: 'Text to embed',
          },
        },
        required: ['text'],
      },
    },
  ]

  // Cast to MCPTool[] - the tools satisfy the interface but TypeScript is being strict
  return tools as MCPTool[]
}

// =============================================================================
// Request Handlers
// =============================================================================

/**
 * Handle tools/list request
 */
export async function handleListTools(id: string | number): Promise<MCPListToolsResponse> {
  return {
    jsonrpc: '2.0',
    id,
    result: {
      tools: getTools(),
    },
  }
}

/**
 * Handle tools/call request
 */
export async function handleToolCall(
  env: Env,
  hostname: string,
  id: string | number,
  toolName: string,
  args: Record<string, unknown>
): Promise<MCPToolCallResponse> {
  try {
    let result: unknown

    // Handle AI tools separately
    if (toolName.startsWith('ai.')) {
      result = await handleAITool(env, toolName, args)
    } else {
      // Route to DO via RPC
      const doId = env.DO.idFromName(hostname)
      const stub = env.DO.get(doId)

      const rpcRequest = {
        type: 'rpc',
        id: `mcp-${id}`,
        method: toolName,
        args: argsToArray(toolName, args),
      }

      const response = await stub.fetch(
        new Request(`https://${hostname}/rpc`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(rpcRequest),
        })
      )

      result = await response.json()
    }

    return {
      jsonrpc: '2.0',
      id,
      result: {
        content: [
          {
            type: 'text',
            text: JSON.stringify(result, null, 2),
          },
        ],
      },
    }
  } catch (error) {
    return {
      jsonrpc: '2.0',
      id,
      error: {
        code: -32603,
        message: error instanceof Error ? error.message : 'Internal error',
      },
    }
  }
}

/**
 * Handle AI tools
 */
async function handleAITool(env: Env, toolName: string, args: Record<string, unknown>): Promise<unknown> {
  if (!env.AI) {
    throw new Error('AI binding not available')
  }

  // Model mapping - runtime selects based on characteristics
  const modelMap: Record<string, string> = {
    best: '@cf/meta/llama-3.1-70b-instruct',
    fast: '@cf/meta/llama-3.1-8b-instruct',
    cost: '@cf/meta/llama-3.1-8b-instruct',
    code: '@cf/meta/llama-3.1-70b-instruct',
  }

  // Type assertion helper for AI model names
  const aiRun = env.AI.run.bind(env.AI) as (model: string, input: unknown) => Promise<unknown>

  switch (toolName) {
    case 'ai.generate': {
      const modelSelector = (args.model as string) || 'best'
      const model = modelMap[modelSelector.split(',')[0]] || modelMap['best']

      const messages = []
      if (args.system) {
        messages.push({ role: 'system', content: args.system as string })
      }
      messages.push({ role: 'user', content: args.prompt as string })

      const result = (await aiRun(model, {
        messages,
        max_tokens: (args.maxTokens as number) || 1024,
        temperature: (args.temperature as number) ?? 0.7,
      })) as { response?: string }

      return { text: result.response || '', model: modelSelector }
    }

    case 'ai.chat': {
      const modelSelector = (args.model as string) || 'best'
      const model = modelMap[modelSelector.split(',')[0]] || modelMap['best']

      const result = (await aiRun(model, {
        messages: args.messages as Array<{ role: string; content: string }>,
        max_tokens: (args.maxTokens as number) || 1024,
        temperature: (args.temperature as number) ?? 0.7,
      })) as { response?: string }

      return {
        message: { role: 'assistant', content: result.response || '' },
        model: modelSelector,
      }
    }

    case 'ai.embed': {
      const texts = Array.isArray(args.text) ? args.text : [args.text]
      const model = '@cf/baai/bge-base-en-v1.5'

      const result = (await aiRun(model, {
        text: texts,
      })) as { data?: Array<number[]> }

      return {
        embeddings: (result.data || []).map((embedding, index) => ({
          embedding,
          index,
          dimensions: embedding.length,
        })),
      }
    }

    default:
      throw new Error(`Unknown AI tool: ${toolName}`)
  }
}

/**
 * Convert named arguments to positional array
 */
function argsToArray(method: string, args: Record<string, unknown>): unknown[] {
  if (method.endsWith('.get') || method.endsWith('.delete')) {
    return [args.id]
  }
  if (method.endsWith('.create')) {
    return [args.data]
  }
  if (method.endsWith('.update')) {
    return [args.id, args.data]
  }
  if (method === 'do.identity.setContext') {
    return [args.context]
  }
  if (method === 'do.schedule') {
    return [args.when, args.callback, args.payload]
  }
  if (method === 'do.schedule.cancel') {
    return [args.id]
  }
  if (method === 'do.cdc.getChanges') {
    return [args.cursor, args.limit]
  }
  if (method === 'do.cdc.subscribe') {
    return [args]
  }

  return Object.keys(args).length > 0 ? [args] : []
}

/**
 * Handle initialize request
 */
export function handleInitialize(hostname: string, id: string | number): MCPToolCallResponse {
  const info: MCPServerInfo = {
    protocolVersion: '2024-11-05',
    capabilities: {
      tools: { listChanged: false },
      resources: { subscribe: false, listChanged: false },
      prompts: { listChanged: false },
      logging: {},
    },
    serverInfo: {
      name: hostname,
      version: '1.0.0',
    },
  }

  return {
    jsonrpc: '2.0',
    id,
    result: {
      content: [{ type: 'text', text: JSON.stringify(info, null, 2) }],
    },
  }
}
